#!/usr/bin/env python

#--------------------------------------------------------------------------
# File and Version Information:
#  $Id$
#
# Description:
#  class TDFileContainer
#
#------------------------------------------------------------------------

"""TDFileContainer - text/table data file container - load/hold/provide access to data from text file.

It is assumed that text data file contains records of the same format and occasionally record-header
beginning with character # (hash in [0] position).
Example of the file content:

# Exp     Run  Date       Time      time(sec)   time(nsec) fiduc  Evnum  Reg  Seg  Row  Col  ...
cxif5315  169  2015-02-22 02:20:47  1424600447  486382070  104421     0  EQU   17  153   48  ...
cxif5315  169  2015-02-22 02:20:47  1424600447  494719789  104424     1  EQU    1  161   32  ...
cxif5315  169  2015-02-22 02:20:47  1424600447  494719789  104424     1  EQU   17  170   51  ...
cxif5315  169  2015-02-22 02:20:47  1424600447  503058551  104427     2  EQU   25  170  310  ...
cxif5315  169  2015-02-22 02:20:47  1424600447  503058551  104427     2  EQU   25  180  292  ...
cxif5315  169  2015-02-22 02:20:47  1424600447  511393301  104430     3  EQU    1  162   27  ...
cxif5315  169  2015-02-22 02:20:47  1424600447  536405573  104439     6  ARC    8   11   41  ...
cxif5315  169  2015-02-22 02:20:47  1424600447  536405573  104439     6  ARC    8   10   20  ...
...

Header (without #) should have the same as data number of literal fields separated by spaces.
Records in the file should be grupped by unique group-id parameter,
for example a group of peaks may have the same event number or some unique index.


Originaly it is designed to work with text file containing peak data generated by peak-finder.
It is adopted to work with any other object type beside peak data.

Usage::

    # !!! NOTE: None is returned whenever requested information is missing.

    # Import
    from pyimgalgos.TDFileContainer import TDFileContainer

    # Initialization
    fname = '/reg/neh/home1/dubrovin/LCLS/rel-mengning/work/pfv2-cxif5315-r0169-2015-09-14T14:28:04.txt'
    fc = TDFileContainer(fname) # optional arguments: indhdr='Evnum', objtype=TDPeak, pbits=0
    fc.print_attrs()

    # Iterate over events
    for evnum in fc.evnum_iterator() :
        evobj = fc.next()
        evobj.print_attrs()
        peaks = evobj() # or evobj.get_objs()

        for peak in peaks :
            peak.print_short()

    # Direct access to event by its number
    evnum = 8
    evobj = fc.event(evnum)
    evobj.print_attrs()

This software was developed for the LCLS project.
If you use all or part of it, please give an appropriate acknowledgment.

@see TDEvent - holds a list of records associated with a single event.
@see TDPeak - user defined class, which provides access to the record data.

@version $Id$

@author Mikhail S. Dubrovin
"""
#------------------------------
__version__ = "$Revision$"
# $Source$
##-----------------------------

import os
from time import time

from pyimgalgos.TDEvent import TDEvent
from pyimgalgos.TDPeak  import TDPeak

##-----------------------------
##-----------------------------

class TDFileContainer :
    """ Load and hold peak list from file and provide access by event index
    """
    def __init__(self, fname, indhdr='Evnum', objtype=TDPeak, pbits=256) :
        """Constructor.
        @param fname   - text table data file name 
        @param indhdr  - header of the field used for event indexing
        @param objtype - object type used for data record processing/access
        @param pbits   - print control bit-word; pbits & 256 - tracking
        """
        if pbits & 256 : print 'c-tor of class %s' % self.__class__.__name__
        self.indhdr = indhdr
        self.objtype = objtype
        self.pbits = pbits
        self.hdr = None
        self.evnum = -1
        #self.lst_of_recs = [] # list of recs loaded from peak data file
        self.lst_evnum  = [] # list of event numbers in the data file
        self.lst_begin  = [] # list of peak record indexes in the lst_of_recs
        self.lst_npeaks = [] # list of numbor of peaks in event 
        #self.map_evnum_to_inds = {} # dictionary containing {evnum : (index_1st_peak, npeaks)}
        
        self.load_recs_from_file(fname)
        self._event_indexing()
        self.reset_indexes()

##-----------------------------

    def reset_indexes(self) :
        """ resets indexes for iterator
        """        
        self.first_iteration = True
        self.evnum_curr = self.lst_evnum[0] # reset current event after indexing
        self.indlst_curr = 0                # reset current index of internal lists
         
##-----------------------------

    def __del__(self) :
        """d-tor
        """
        if self.pbits & 256 : print 'd-tor of class %s' % self.__class__.__name__
        pass

##-----------------------------

    def __call__(self) :
        if self.pbits & 256 : print """default method of class %s""" % self.__class__.__name__
        for i,rec in enumerate(self.lst_of_recs) :
            if i>5 : break
            print i, len(rec)

##-----------------------------

    def print_attrs(self) :
        print 'Attributes of the class %s object' % self.__class__.__name__
        print '  fname : %s' % self.fname,\
              '\n  pbits : %d' % self.pbits,\
              '\n  hdr   : %s' % self.hdr,\
              '\n  nrecs : %d' % len(self.lst_of_recs),\
              '\n  Auto-defined evnum index in the peak data : %d' % self.ievnum

##-----------------------------

    def load_recs_from_file(self, fname) :
        if not os.path.lexists(fname) : raise IOError('File %s is not found' % fname)
        self.fname = fname
        t0_sec = time()
        f=open(fname,'r')
        #self.lst_of_recs = [rec.rstrip('\n') for rec in f]
        self.lst_of_recs = f.readlines()
        f.close()
        if self.pbits & 256 : print 'File loading time %.3f sec' % (time()-t0_sec)

##-----------------------------

    def part_rec_parser(self, rec) :
        """ 1. saves the 1st header in self.hdr, return None for header
            2. defines index of the field self.indhdr (='Evnum')
            3. returns None for empty recs (if any)
            4. returns event number found in the peak data
        """
        if rec[0]=='#' : # rec is header
            if  self.hdr is None :
                self.hdr = rec.lstrip('#').rstrip('\n')
                self.ievnum = self.hdr.split().index(self.indhdr)
                print 'self.ievnum', self.ievnum
            return None

        if len(rec)==1 : return None # rec is empty

        fields = rec.split(None,self.ievnum+1)    
        return int(fields[self.ievnum])

##-----------------------------

    def _event_indexing(self) :
        """loops over list of peaks, makes lists and dictionary for indexing
        """
        if self.pbits & 256 : print '_event_indexing'
        t0_sec = time()

        self.count = 0     
        for ind, rec in enumerate(self.lst_of_recs) :
            
            evnum = self.part_rec_parser(rec)
            if evnum is None : continue # in case of comments and empty recs

            # check if peak record is from the next event and add it to the dictionary
            if evnum != self.evnum :                
                if not (self.evnum < 0) : # skip 1st record
                    self.lst_npeaks.append(self.count) 
                    self.count = 1
                self.evnum = evnum
                self.lst_evnum.append(evnum)
                self.lst_begin.append(ind)
                 
                #print 'New event number: %d' % evnum
            else :
                self.count += 1

            #if ind>100 : break
 
        self.lst_npeaks.append(self.count) # add for last record

        #make dictionary
        #self.map_evnum_to_inds = dict(zip(self.lst_evnum, zip(self.lst_begin, self.lst_npeaks)))

        if self.pbits & 256 :
            #print 'Last event self.map_evnum_to_inds[%d] = %s' % (self.evnum, self.map_evnum_to_inds[self.evnum])
            print 'Last event %d contains %d peaks' % (self.evnum, self.count)
            print 'Event indexing time %.3f sec' % (time()-t0_sec)

##-----------------------------
# This is time consuming operation
#    def list_of_events(self) :
#        """returns list of event objects
#        """
#        self.reset_indexes()
#        return [self.next() for evnum in self.lst_evnum]
#
##-----------------------------

    def event_numbers(self) :
        """returns list of event numbers in the file
        """
        return self.lst_evnum

##-----------------------------

    def evnum_iterator(self) :
        """resets indexes to the beginning of arrays and returns list of event numbers
        """
        self.reset_indexes()
        return self.lst_evnum

##-----------------------------

    def number_of_events(self) :
        """returns number of events in file
        """
        return len(self.lst_evnum)

##-----------------------------

    def current_event_number(self) :
        """returns current event number
        """
        return self.evnum_curr

##-----------------------------

    def header(self) :
        """returns string header
        """
        return self.hdr

##-----------------------------

    def _event_for_index(self) :
        """returns event for specified range of indexes
        """
        self.evnum_curr = self.lst_evnum [self.indlst_curr]
        begin           = self.lst_begin [self.indlst_curr]
        npeaks          = self.lst_npeaks[self.indlst_curr]

        if self.pbits & 256 : 
            print 'evnum_curr=%d  indlst_curr=%d  begin=%d  npeaks=%d' %\
                  (self.evnum_curr, self.indlst_curr, begin, npeaks)

        evt_recs = self.lst_of_recs[begin:begin+npeaks]
        #print '%s\nList of peaks for event %d' % (80*'_', self.evnum)
        #for rec in recs : print rec

        return TDEvent(evt_recs, self.objtype, pbits=self.pbits)

##-----------------------------

    def event(self, evnum=None) :
        """returns current or specified event
        """
        if self.pbits & 256 : print 'event(evnum=%s)' % str(evnum)
        if evnum is not None :
            if not (evnum in self.lst_evnum) : return None
            self.indlst_curr = self.lst_evnum.index(evnum)        
        return self._event_for_index()

##-----------------------------

    def next(self) :
        """returns next event
        """
        if self.pbits & 256 : print 'next event'

        if  self.first_iteration :
            self.first_iteration = False
            return self._event_for_index() # do not increment indexes on first iteration

        if  self.indlst_curr < len(self.lst_evnum)-1 :
            self.indlst_curr += 1
            return self._event_for_index()
        else :
            if self.pbits : print 'WARNING: %s.next() reached the end of the list, return None'%\
               self.__class__.__name__
            return None

##-----------------------------

    def previous(self) :
        """returns previous event
        """
        if self.pbits & 256 : print 'previous event'

        if  self.first_iteration :
            self.first_iteration = False
            return self._event_for_index() # do not decrement indexes on first iteration

        if  self.indlst_curr > 0 :
            self.indlst_curr -= 1
            return self._event_for_index()
        else :
            if self.pbits : print 'WARNING: %s.previous() reached the beginning of the list, return None'%\
               self.__class__.__name__
            return None

##-----------------------------
##-----------------------------
##-----------------------------
##-----------------------------
##-----------------------------

def do_work() :
    """ do something here
    """
    fname = '/reg/neh/home1/dubrovin/LCLS/rel-mengning/work/pfv2-cxif5315-r0169-2015-09-14T14:28:04.txt'
    fc = TDFileContainer(fname, indhdr='Evnum', objtype=TDPeak, pbits=0)
    fc.print_attrs()
    fc()

    # Direct access to TDEvent object
    evtobj = fc.event(8)
    evtobj.print_attrs()

    t0_sec = time()

    for evnum in fc.evnum_iterator() :
        evobj = fc.next()
        print '%s\nEvent %d  ' % (80*'_', evnum)
        for peak in evobj() :
            print ' ',
            peak.print_short()

        for i, peak in enumerate(evobj()) :
            print '  peak#%2d  bkgd=%5.1f  rms=%5.1f  S/N=%5.1f' % (i, peak.bkgd, peak.rms, peak.son)
        
    print '\nTime to iterate using next() %.3f sec' % (time()-t0_sec)

    #t0_sec = time()
    #events = fc.list_of_events()  
    #print 'Time to generate list of event objects %.3f sec' % (time()-t0_sec)

##-----------------------------
if __name__ == "__main__" :
    do_work()
    print('Test is completed')
    #sys.exit('Processing is completed')
##-----------------------------
